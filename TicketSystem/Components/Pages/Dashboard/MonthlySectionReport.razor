@page "/monthly-section-report"
@using TicketSystem.Services
@using static TicketSystem.Services.OrderService
@inject IJSRuntime JS
@inject OrderService OrderService
@rendermode InteractiveServer

<h3 class="text-center my-3">📊 تقرير الأقسام - مقارنة الشهر الحالي و الشهر السابق</h3>

<div class="container-fluid">
    <div class="row g-3">
        <!-- الشهر الحالي -->
        <div class="col-12 col-lg-6">
            <div class="card shadow-sm border-success">
                <div class="card-body text-center">
                    <h4 class="mb-3 text-success">📊 الشهر الحالي</h4>
                    <h5 id="sectionTitleCurrent" class="mb-2"></h5>
                    <p id="sectionDiffCurrent" class="fw-bold"></p>
                    <div class="chart-container w-100">
                        <canvas id="sectionChartCurrent"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <!-- الشهر السابق -->
        <div class="col-12 col-lg-6">
            <div class="card shadow-sm border-danger">
                <div class="card-body text-center">
                    <h4 class="mb-3 text-danger">📊 الشهر السابق</h4>
                    <h5 id="sectionTitlePrev" class="mb-2"></h5>
                    <br />
                    <br />
                    <div class="chart-container w-100">
                        <canvas id="sectionChartPrev"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

@code {
    private List<SectionDayData> CurrentChartData = new();
    private List<SectionDayData> PrevChartData = new();

    private List<string> DaysLabelsCurrent = new();
    private List<string> DaysLabelsPrev = new();

    private Dictionary<string, List<int>> SectionSeriesCurrent = new();
    private Dictionary<string, List<int>> SectionSeriesPrev = new();

    private Dictionary<string, int> SectionMonthlyTotalsCurrent = new();
    private Dictionary<string, int> SectionMonthlyTotalsPrev = new();

    private bool CurrentChartHasData = false;
    private bool PrevChartHasData = false;

    protected override async Task OnInitializedAsync()
    {
        var now = DateTime.Now;
        var currentMonth = now.Month;
        var currentYear = now.Year;

        var prev = now.AddMonths(-1);
        var prevMonth = prev.Month;
        var prevYear = prev.Year;

        CurrentChartData = await OrderService.GetSectionMonthlyDataAsync(currentMonth, currentYear);
        PrevChartData = await OrderService.GetSectionMonthlyDataAsync(prevMonth, prevYear);

        int daysInCurrent = DateTime.DaysInMonth(currentYear, currentMonth);
        int daysInPrev = DateTime.DaysInMonth(prevYear, prevMonth);

        DaysLabelsCurrent = Enumerable.Range(1, daysInCurrent).Select(d => d.ToString()).ToList();
        DaysLabelsPrev = Enumerable.Range(1, daysInPrev).Select(d => d.ToString()).ToList();

        var sections = CurrentChartData.Select(r => r.SectionName)
                        .Concat(PrevChartData.Select(r => r.SectionName))
                        .Distinct()
                        .ToList();

        foreach (var section in sections)
        {
            var seriesCur = new List<int>();
            for (int day = 1; day <= daysInCurrent; day++)
            {
                var total = CurrentChartData
                    .Where(r => r.SectionName == section && r.Day == day)
                    .Sum(r => r.Total);
                seriesCur.Add(total);
            }
            SectionSeriesCurrent[section] = seriesCur;
            SectionMonthlyTotalsCurrent[section] = seriesCur.Sum();

            var seriesPrev = new List<int>();
            for (int day = 1; day <= daysInPrev; day++)
            {
                var total = PrevChartData
                    .Where(r => r.SectionName == section && r.Day == day)
                    .Sum(r => r.Total);
                seriesPrev.Add(total);
            }
            SectionSeriesPrev[section] = seriesPrev;
            SectionMonthlyTotalsPrev[section] = seriesPrev.Sum();
        }

        CurrentChartHasData = SectionSeriesCurrent.Count > 0 && SectionSeriesCurrent.Values.Any(v => v.Sum() > 0);
        PrevChartHasData = SectionSeriesPrev.Count > 0 && SectionSeriesPrev.Values.Any(v => v.Sum() > 0);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            if (CurrentChartHasData || PrevChartHasData)
            {
                await JS.InvokeVoidAsync("renderSectionChartMonths",
                    DaysLabelsCurrent, SectionSeriesCurrent, SectionMonthlyTotalsCurrent,
                    DaysLabelsPrev, SectionSeriesPrev, SectionMonthlyTotalsPrev);
            }
        }
    }
}
<style>
    .chart-container {
        position: relative;
        width: 100%;
        height: 300px;
    }

    @@media (min-width: 768px) {
        .chart-container

    {
        height: 60vh;
    }

    }

    .border-success {
        border-top: 4px solid #1cc88a !important;
    }

    .border-danger {
        border-top: 4px solid #e74a3b !important;
    }
</style>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
    window.renderSectionChartMonths = (labelsCur, seriesCur, totalsCur, labelsPrev, seriesPrev, totalsPrev) => {
        var ctxCur = document.getElementById('sectionChartCurrent')?.getContext('2d');
        var ctxPrev = document.getElementById('sectionChartPrev')?.getContext('2d');

        var sectionNames = Array.from(new Set([...Object.keys(seriesCur || {}), ...Object.keys(seriesPrev || {})]));
        if (sectionNames.length === 0) return;

        var colors = [
            '#4e73df', '#1cc88a', '#e74a3b',
            '#f6c23e', '#36b9cc', '#6610f2',
            '#fd7e14', '#20c997', '#6f42c1'
        ];

        // تنظيف أي Charts/Intervals سابقة
        try {
            if (window.sectionChartCur) { window.sectionChartCur.destroy(); window.sectionChartCur = null; }
            if (window.sectionChartPrev) { window.sectionChartPrev.destroy(); window.sectionChartPrev = null; }
            if (window.sectionInterval) { clearInterval(window.sectionInterval); window.sectionInterval = null; }
        } catch (e) {
            console.warn("cleanup error", e);
        }

        var currentIndex = 0;

        function formatNumber(n) {
            var num = Number(n) || 0;
            return num.toLocaleString(); // يفصل الآلاف حسب الإعدادات المحلية
        }

        function createChartsForSection(index) {
            var sec = sectionNames[index];
            var color = colors[index % colors.length];

            var dataCur = seriesCur[sec] || labelsCur.map(_ => 0);
            var dataPrev = seriesPrev[sec] || labelsPrev.map(_ => 0);

            if (ctxCur) {
                window.sectionChartCur = new Chart(ctxCur, {
                    type: 'line',
                    data: {
                        labels: labelsCur,
                        datasets: [{
                            label: sec,
                            data: dataCur,
                            borderColor: color,
                            backgroundColor: color + '55',
                            fill: true,
                            tension: 0.2,
                            pointRadius: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            title: { display: false }
                        },
                        interaction: { mode: 'index', intersect: false }
                    }
                });
            }

            if (ctxPrev) {
                window.sectionChartPrev = new Chart(ctxPrev, {
                    type: 'line',
                    data: {
                        labels: labelsPrev,
                        datasets: [{
                            label: sec,
                            data: dataPrev,
                            borderColor: color,
                            backgroundColor: color + '55',
                            fill: true,
                            tension: 0.2,
                            pointRadius: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            title: { display: false }
                        },
                        interaction: { mode: 'index', intersect: false }
                    }
                });
            }

            updateTitlesByIndex(index);
        }

        function updateCharts(index) {
            var sec = sectionNames[index];
            var color = colors[index % colors.length];

            var dataCur = seriesCur[sec] || labelsCur.map(_ => 0);
            var dataPrev = seriesPrev[sec] || labelsPrev.map(_ => 0);

            if (window.sectionChartCur) {
                window.sectionChartCur.data.labels = labelsCur;
                window.sectionChartCur.data.datasets[0].data = dataCur;
                window.sectionChartCur.data.datasets[0].label = sec;
                window.sectionChartCur.data.datasets[0].borderColor = color;
                window.sectionChartCur.data.datasets[0].backgroundColor = color + '55';
                window.sectionChartCur.update();
            }

            if (window.sectionChartPrev) {
                window.sectionChartPrev.data.labels = labelsPrev;
                window.sectionChartPrev.data.datasets[0].data = dataPrev;
                window.sectionChartPrev.data.datasets[0].label = sec;
                window.sectionChartPrev.data.datasets[0].borderColor = color;
                window.sectionChartPrev.data.datasets[0].backgroundColor = color + '55';
                window.sectionChartPrev.update();
            }

            updateTitlesByIndex(index);
        }

        function updateTitlesByIndex(index) {
            var sec = sectionNames[index];
            var totalCur = Number(totalsCur[sec] ?? 0);
            var totalPrev = Number(totalsPrev[sec] ?? 0);

            document.getElementById("sectionTitleCurrent").innerText = sec + " - المجموع: " + formatNumber(totalCur);
            document.getElementById("sectionTitlePrev").innerText = sec + " - المجموع: " + formatNumber(totalPrev);

            // حساب الفرق/النسبة بشكل صحيح ومعالجة حالة القسمة على صفر
            var diffText = "";
            var color = "gray";

            var absDiff = totalCur - totalPrev;
            var absDiffAbs = Math.abs(absDiff);

            if (totalPrev === 0) {
                if (totalCur === 0) {
                    diffText = "بدون تغيير";
                    color = "gray";
                } else {
                    // عندما يكون الشهر السابق صفر لا يمكن حساب نسبة تغيير "معقولة"
                    diffText = "⬆️ زيادة " + formatNumber(absDiffAbs) + " (الشهر السابق = 0 — النسبة غير معرفة)";
                    color = "green";
                }
            } else {
                var pct = (absDiff / totalPrev) * 100;
                var pctAbs = Math.abs(pct).toFixed(1);

                if (absDiff > 0) {
                    diffText = "⬆️ زيادة " + formatNumber(absDiffAbs) + " (" + pctAbs + "%)";
                    color = "green";
                } else if (absDiff < 0) {
                    diffText = "⬇️ انخفاض " + formatNumber(absDiffAbs) + " (" + pctAbs + "%)";
                    color = "red";
                } else {
                    diffText = "بدون تغيير";
                    color = "gray";
                }
            }

            // نعرض نفس النص في البطاقتين (يمكن تغييره إذا أردت نصًا مختلفًا للـ "السابق")
            document.getElementById("sectionDiffCurrent").innerText = diffText;
            document.getElementById("sectionDiffCurrent").style.color = color;
        }

        // إنشاء الجراف لأول قسم
        createChartsForSection(0);

        // التبديل بين الأقسام كل 20 ثانية (احفظ الـ interval على window حتى نقدر ننظفه لاحقاً)
        window.sectionInterval = setInterval(() => {
            currentIndex = (currentIndex + 1) % sectionNames.length;
            updateCharts(currentIndex);
        }, 20000);
    };
</script>
